<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>æ‹è²¼ï½œå‹•ä½œå¼•å°æ¨¡å¼ (åˆæˆç‰ˆ)</title>

<style>
html,body{
  margin:0; background:#000; overflow:hidden;
  overscroll-behavior:none; touch-action:manipulation;
  font-family:"Noto Sans TC",system-ui;
}
*{user-select:none;-webkit-user-select:none;}
/* åŠ å…¥åœ¨åŸæœ¬ style çš„æœ€å¾Œé¢å³å¯ */
body, button, .startBtn { cursor: none !important; }

#fake-cursor { 
  position: fixed; top: 0; left: 0; width: 100px; height: 100px; 
  pointer-events: none; z-index: 99999; will-change: transform; 
}
#fake-cursor-img { 
  width: 100%; height: 100%; 
  background-image: url('cursor.png'); 
  background-size: contain; background-repeat: no-repeat; 
  transform-origin: center 80%; 
}
#fake-cursor.is-clicking #fake-cursor-img { 
  background-image: url('cursor-click.png'); 
  transform: rotate(-5deg); 
}
/* å¼·åˆ¶å…¨è¢å¹• */
.stage {
  width: 100vw;   
  height: 100vh;  
  position: relative;
  background: #000;
  overflow: hidden; 
}

#composite-canvas {
  width: 100%;
  height: 100%;
  object-fit: cover; 
  display: block;
}
#cam, #char-video {
  position: absolute;
  top: 0; left: 0;
  width: 1px; height: 1px;
  opacity: 0; 
  pointer-events: none;
  z-index: -1;
}

/* å³å´åŠèº«å¼•å°æ¡† */
.guide-box {
  position: absolute;
  bottom: 0; 
  right: 20%; 
  width: 500px; 
  height: 60%;  
  border: 4px dashed rgba(255, 255, 255, 0.3); 
  border-bottom: none; 
  border-radius: 250px 250px 0 0; 
  pointer-events: none; 
  z-index: 50; 
  box-shadow: none;
}

.guide-box::before {
  content: ""; 
  position: absolute;
  width: 180px; 
  height: 180px;
  top: -220px; 
  left: 50%;
  transform: translateX(-50%); 
  border: 4px dashed rgba(255, 255, 255, 0.3); 
  border-radius: 50%; 
}

/* èƒ¸å‰æ‰‹å‹¢æ–‡å­—æç¤ºå€ */
.hand-area {
  position: absolute;
  top: 10%; 
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  height: 200px;
  border: none; 
  background: transparent;
  display: flex; justify-content: center; align-items: center;
  z-index: 60;
}

.hand-area span {
  background: rgba(0, 0, 0, 0.2); 
  padding: 8px 20px;
  border-radius: 50px;
  color: rgba(255, 255, 255, 0.7); 
  font-weight: 500; 
  font-size: 24px;
  letter-spacing: 2px;
  white-space: nowrap;
}

/* --- å‹•æ…‹æç¤ºè‰²å¡Š (é»ƒè‰²å…‰åœˆ) --- */
.pose-block {
  position: absolute;
  background: rgba(255, 255, 255, 0.363); /* åŠé€æ˜é»ƒè‰² */
  border: 0px dashed rgba(255, 255, 255, 0.514); /* ç™½è‰²è™›ç·š */
  border-radius: 10%;
  box-shadow: 0 0 0px rgba(255, 255, 255, 0.6);
  pointer-events: none;
  z-index: 55;
  animation: floatBlock 2s infinite ease-in-out;
}

@keyframes floatBlock {
  0%, 100% { transform: scale(1); opacity: 0.8; }
  50% { transform: scale(1.05); opacity: 1; }
}

/* æ¨™é¡Œé®ç½© */
.loading{
  position:absolute; inset:0; display:flex; flex-direction: column;
  justify-content: center; align-items: center; gap: 20px;
  background:rgba(0,0,0,.7); color:#fff;
  opacity:0; transition:.5s; z-index: 70; pointer-events: none;
  backdrop-filter: blur(5px);
}
.loading h2 { font-size: 60px; margin: 0; font-weight: 900; }
.loading p { font-size: 32px; margin: 0; opacity: 0.9; }
.show{opacity:1; pointer-events:auto;}

/* ä¸­å¤®æç¤ºæ–‡å­— (ç·´ç¿’æ™‚é–“ / å€’æ•¸ / æ‹æ”ä¸­) */
.center-status {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: transparent; 
  border: none;
  color: rgba(255, 255, 255, 0.8); 
  text-shadow: 0 0 10px rgba(0,0,0,0.5);
  font-size: 60px;
  font-weight: 900;
  letter-spacing: 5px;
  pointer-events: none;
  z-index: 90;
  opacity: 0;
  transition: opacity 0.3s;
  text-align: center;
}
.center-status.active {
  opacity: 1;
}

/* é–‹å§‹æŒ‰éˆ• */
.startBtn{
  position:absolute; inset:0; margin:auto; width:420px; height:120px;
  font-size:32px; font-weight:900; border-radius:60px; border:0; cursor:pointer;
  background: #bfefff; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  transition: transform 0.2s; z-index: 80;
}
.startBtn:active { transform: scale(0.95); }
</style>
</head>

<body>
<div class="stage">
  <canvas id="composite-canvas" width="1920" height="1080"></canvas>
  
  <div class="guide-box">
    <div id="pose-container"></div>
    
    <div class="hand-area">
      <span id="hand-msg">æ‰‹æ”¾èƒ¸å‰</span>
    </div>
  </div>

  <video id="cam" autoplay playsinline muted></video>
  <video id="char-video" loop muted playsinline crossorigin="anonymous"></video>
  <img id="char-img" style="display:none;" crossorigin="anonymous">
  
  <div id="loading" class="loading">
    <h2 id="msg-title">æº–å‚™ä¸­...</h2>
    <p id="msg-sub">è«‹ç¨å€™</p>
  </div>

  <div id="center-status" class="center-status">3</div>

  <button id="start" class="startBtn">ğŸ“¸ é–‹å§‹å‹•æ…‹æ‹è²¼</button>
</div>

<div id="fake-cursor"><div id="fake-cursor-img"></div></div>

<script>
/* =====================
   0. è³‡æ–™åº«å·¥å…·
===================== */
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("PhotoboothDB", 3);
    request.onupgradeneeded = e => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains("videos")) db.createObjectStore("videos");
    };
    request.onsuccess = e => resolve(e.target.result);
    request.onerror = e => { console.error("DB Error", e); reject(e); };
  });
}

async function saveClipToDB(blob, index) {
  const db = await openDB();
  return new Promise((resolve) => {
    const tx = db.transaction("videos", "readwrite");
    const store = tx.objectStore("videos");
    store.put(blob, `clip_${index}`);
    tx.oncomplete = () => resolve();
    tx.onerror = () => resolve(); 
  });
}

async function saveFullVideoToDB(blob) {
  const db = await openDB();
  return new Promise((resolve) => {
    const tx = db.transaction("videos", "readwrite");
    const store = tx.objectStore("videos");
    store.put(blob, "latest");
    tx.oncomplete = () => resolve();
  });
}

/* =====================
   1. è¨­å®šèˆ‡æµç¨‹
===================== */
let currentRole = 'æ·˜æ°£å¥³'; 
try {
  const savedData = JSON.parse(localStorage.getItem('photobooth_template'));
  if (savedData && savedData.role) {
    currentRole = savedData.role;
  }
} catch (e) {
  console.log("è®€å–è§’è‰²å¤±æ•—ï¼Œä½¿ç”¨é è¨­å€¼");
}

// === è§’è‰²å‹•ä½œä½ç½®è¨­å®š (20ç¨®å€‹æ€§) ===
const baseRole = currentRole.replace(/[ç”·å¥³]$/, '');

const POSE_DATA = {
  // 1. æ´»æ½‘ (é ­å…©æ—)
  'æ´»æ½‘': { 
    text: 'æ‰‹åœ¨é ­å…©æ—ï¼Œé ­å·¦å³æ–æ™ƒ', 
    blocks: [
      { top: '-180px', left: '30px', w: '120px', h: '120px' },
      { top: '-180px', right: '30px', w: '120px', h: '120px' }
    ] 
  },
  // 2. è°æ˜ (é ­å–®é‚Š)
  'è°æ˜': { 
    text: 'æ‰‹åœ¨é ­æ—é‚Š', 
    blocks: [ { top: '-180px', right: '-40px', w: '120px', h: '120px' } ] 
  },
  // 3. å®³ç¾ (é®è‡‰ + è‡‰æ—)
  'å®³ç¾': { 
    text: 'ä¸€æ‰‹é®è‡‰ï¼Œä¸€æ‰‹åœ¨è‡‰æ—é‚Š', 
    blocks: [
      { top: '-200px', left: '36%', w: '140px', h: '140px' }, // è‡‰ä¸­
      { top: '-150px', right: '350px', w: '100px', h: '100px' } // è‡‰æ—
    ] 
  },
  // 4. æ•éŠ³ (é ­æ— + èƒ¸å‰)
  'æ•éŠ³': {
    text: 'æ‰‹å…ˆåœ¨é ­æ—é‚Šï¼Œå†æ»‘éåˆ°èƒ¸å‰',
    blocks: [
      { top: '-180px', right: '310px', w: '100px', h: '100px' },
      { top: '15%', left: '30%', w: '40%', h: '30%' }
    ]
  },
  // 5. å¹½é»˜ (è…°å…©æ—)
  'å¹½é»˜': { 
    text: 'æ‰‹åœ¨è…°å…©æ—', 
    blocks: [
      { top: '60%', left: '-40px', w: '120px', h: '120px' },
      { top: '60%', right: '-40px', w: '120px', h: '120px' }
    ] 
  },
  // 6. å‹‡æ•¢ (è…°å‰)
  'å‹‡æ•¢': {
    text: 'æ‰‹åœ¨è…°å‰',
    blocks: [ { top: '60%', left: '25%', w: '50%', h: '25%' } ]
  },
  // 7. é è¨­èƒ¸å‰ (åŒ…å«å‰©ä¸‹çš„æ‰€æœ‰è§’è‰²ï¼Œä»¥åŠæ¯”æ€§åˆ¥æ™‚ä½¿ç”¨)
  'default': { 
    text: 'æ‰‹åœ¨èƒ¸å‰', 
    blocks: [ { top: '15%', left: '20%', w: '60%', h: '30%' } ] 
  }
};

const chestRoles = [
  'æ·˜æ°£', 'å¤§æ–¹', 'å†·éœ', 'æ–‡éœ', 'æ²‰ç©©', 'æº«æŸ”', 
  'å–„è‰¯', 'è€å¿ƒ', 'æ¨‚è§€', 'è‡ªä¿¡', 'æœæ–·', 'ç¨ç«‹', 
  'ç´°å¿ƒ', 'è¬¹æ…'
];

chestRoles.forEach(role => {
  POSE_DATA[role] = POSE_DATA['default'];
});

// â˜…â˜…â˜… ä¿®æ”¹é‡é»ï¼šæ¸²æŸ“æç¤ºæ¡†å‡½å¼ (æ–°å¢ forceChest åƒæ•¸) â˜…â˜…â˜…
function renderPoseGuide(forceChest = false) {
  const handMsgEl = document.getElementById('hand-msg');
  const container = document.getElementById('pose-container');
  
  // å¦‚æœ forceChest ç‚º true (ä»£è¡¨æ­£åœ¨æ¯”æ€§åˆ¥)ï¼Œå¼·åˆ¶ä½¿ç”¨ default è¨­å®š
  // å¦å‰‡ä½¿ç”¨è§’è‰²çš„è¨­å®š
  const config = forceChest ? POSE_DATA['default'] : (POSE_DATA[baseRole] || POSE_DATA['default']);

  if(handMsgEl) handMsgEl.textContent = config.text;

  if(container) {
    container.innerHTML = '';
    config.blocks.forEach(b => {
      const div = document.createElement('div');
      div.className = 'pose-block';
      if(b.top) div.style.top = b.top;
      if(b.bottom) div.style.bottom = b.bottom;
      if(b.left) div.style.left = b.left;
      if(b.right) div.style.right = b.right;
      div.style.width = b.w;
      div.style.height = b.h;
      container.appendChild(div);
    });
  }
}

// åˆå§‹å…ˆæ¸²æŸ“ä¸€æ¬¡è§’è‰²é è¨­ (ç¬¬ä¸€æ®µ)
renderPoseGuide(false);

// === å½±ç‰‡é †åºè¨­å®š ===
const COMPLEX_ROLES = [ 'è‡ªä¿¡å¥³', 'è‡ªä¿¡ç”·', 'æœæ–·å¥³', 'æœæ–·ç”·', 'ç¨ç«‹å¥³', 'ç¨ç«‹ç”·' ];
const isComplex = COMPLEX_ROLES.includes(currentRole);
let SEQUENCE = [];

if (isComplex) {
  SEQUENCE = [
    { title: 'å‹•ä½œ 1', sub: 'è«‹è·Ÿè‘—å°äººåšï¼šæ‰‹èªå‹•ä½œåˆ†è§£(ä¸€)', type: 'video', src: `video/${currentRole}/1.webm` },
    { title: 'å‹•ä½œ 2', sub: 'å‹•ä½œæµæš¢é€£çµï¼šæ‰‹èªå‹•ä½œåˆ†è§£(äºŒ)', type: 'video', src: `video/${currentRole}/2.webm` },
    { title: 'å‹•ä½œ 3', sub: 'æœ€å¾Œä¸€å¼µï¼šæ¯”å‡ºä½ çš„æ€§åˆ¥', type: 'video', src: `video/${currentRole}/3.webm` }
  ];
} else {
  SEQUENCE = [
    { title: 'å‹•ä½œ 1', sub: 'è«‹è·Ÿè‘—å°äººåšï¼šæ¯”å‡ºå½¢å®¹è©æ‰‹èª', type: 'video', src: `video/${currentRole}/1.webm` },
    { title: 'å‹•ä½œ 2', sub: 'æœ€å¾Œä¸€å¼µï¼šæ¯”å‡ºä½ çš„ç”Ÿç†æ€§åˆ¥', type: 'video', src: `video/${currentRole}/2.webm` }
  ];
}

const cam = document.getElementById('cam');
const charVideo = document.getElementById('char-video');
const canvas = document.getElementById('composite-canvas');
const ctx = canvas.getContext('2d');
const charImg = document.getElementById('char-img');
let currentMediaType = 'video'; 

const loading = document.getElementById('loading');
const msgTitle = document.getElementById('msg-title');
const msgSub = document.getElementById('msg-sub');
const startBtn = document.getElementById('start');
const centerStatus = document.getElementById('center-status');

const sleep = ms => new Promise(r=>setTimeout(r,ms));
let stream = null;
let canvasStream = null;
let fullRecorder = null;
let fullChunks = [];
let shooting = false;
let animationId = null;

const charBuffer = document.createElement('canvas');
charBuffer.width = 1920;
charBuffer.height = 1080;
const charBufferCtx = charBuffer.getContext('2d');

/* =====================
   2. ç•«é¢åˆæˆé‚è¼¯
===================== */
function startCanvasLoop() {
  canvas.width = 1920;
  canvas.height = 1080;

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 1. ç¹ªè£½ç›¸æ©Ÿ
    ctx.save();
    ctx.translate(canvas.width, 0);
    ctx.scale(-1, 1);
    
    if (cam.readyState >= 2) {
      ctx.drawImage(cam, 0, 0, canvas.width, canvas.height);
    }
    ctx.restore();

    // 2. ç¹ªè£½è§’è‰²
    const scale = 1;       
    const marginLeft = 90;    
    const marginBottom = -180; 

    const charH = canvas.height * scale; 
    const y = canvas.height - charH - marginBottom;
    const x = marginLeft;

    if (currentMediaType === 'video') {
       if (charVideo.videoWidth > 0 && charVideo.videoHeight > 0) {
          if (charVideo.readyState >= 3) {
             charBufferCtx.clearRect(0, 0, charBuffer.width, charBuffer.height);
             charBufferCtx.drawImage(charVideo, 0, 0, charBuffer.width, charBuffer.height);
          }
          const ratio = charVideo.videoWidth / charVideo.videoHeight;
          const charW = charH * ratio; 
          ctx.drawImage(charBuffer, 0, 0, charBuffer.width, charBuffer.height, x, y, charW, charH);
       }
    } 
    else if (currentMediaType === 'image') {
       if (charImg.complete && charImg.naturalHeight !== 0) {
          const ratio = charImg.naturalWidth / charImg.naturalHeight;
          const charW = charH * ratio;
          ctx.drawImage(charImg, x, y, charW, charH);
       }
    }
    animationId = requestAnimationFrame(draw);
  }
  draw();
}

async function startCamera(){
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 } },
      audio: false
    });
    cam.srcObject = stream;
    await cam.play();
    startCanvasLoop();
    canvasStream = canvas.captureStream(30);
  } catch (err) {
    console.error("ç›¸æ©Ÿå¤±æ•—", err);
    alert("ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿ");
  }
}

/* =====================
   3. æµç¨‹æ§åˆ¶å·¥å…·
===================== */

function setStepUI(index) {
  const step = SEQUENCE[index];
  currentMediaType = step.type;

  if (step.type === 'image') {
    charImg.src = step.src;
    charVideo.pause();
  } else {
    if (charVideo.getAttribute('src') !== step.src) {
      charVideo.src = step.src;
      charVideo.play().catch(e => console.log('Autoplay blocked'));
    } else {
      charVideo.play();
    }
  }
  
  msgTitle.innerHTML = step.title;
  msgSub.textContent = step.sub;
  loading.classList.add('show');
}

async function waitVideoLoops(loops = 3) {
  if (currentMediaType === 'video') {
    if (charVideo.readyState < 1) {
       await new Promise(r => charVideo.onloadedmetadata = r);
    }
    const duration = charVideo.duration;
    const oneLoopTime = (duration && duration !== Infinity) ? duration * 1000 : 3000;
    await sleep(oneLoopTime * loops);
  } else {
    await sleep(5000);
  }
}

async function countdownCenter(){
  centerStatus.classList.add('active');
  for(let i=3; i>0; i--){
    centerStatus.textContent = i;
    await sleep(1000);
  }
}

function recordClip(duration = 2500) {
  return new Promise((resolve) => {
    const chunks = [];
    let mimeType = 'video/webm;codecs=vp9';
    if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/webm';
    if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/mp4';

    const recorder = new MediaRecorder(canvasStream, { mimeType, videoBitsPerSecond: 5000000 });
    
    recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
    recorder.onstop = () => resolve(new Blob(chunks, { type: mimeType }));
    
    recorder.start();
    setTimeout(() => recorder.stop(), duration);
  });
}

function startFullRecording(){
  if(!canvasStream) return;
  fullChunks = [];
  try {
    fullRecorder = new MediaRecorder(canvasStream, { videoBitsPerSecond: 5000000 });
    fullRecorder.ondataavailable = e => { if(e.data.size>0) fullChunks.push(e.data); };
    fullRecorder.start();
  } catch(e) { console.error(e); }
}

function stopFullRecording(){
  return new Promise((resolve) => {
    if(!fullRecorder || fullRecorder.state === 'inactive') { resolve(); return; }
    fullRecorder.onstop = async () => {
      const blob = new Blob(fullChunks, { type: fullRecorder.mimeType });
      localStorage.setItem('booth_video_mime', fullRecorder.mimeType);
      await saveFullVideoToDB(blob);
      resolve();
    };
    fullRecorder.stop();
  });
}

/* =====================
   4. ä¸»æµç¨‹ (Shoot)
===================== */
async function shoot(){
  if(shooting) return;
  shooting = true;
  startBtn.style.display = 'none';

  if(!stream) await startCamera();
  await sleep(500);
  
  startFullRecording();

  const totalSteps = SEQUENCE.length;

  for(let i=0; i<totalSteps; i++) {
    // â˜…â˜…â˜… ä¿®æ”¹ï¼šå‹•æ…‹æ›´æ–°æç¤ºæ¡† â˜…â˜…â˜…
    // åˆ¤æ–·æ˜¯å¦ç‚ºæœ€å¾Œä¸€æ­¥ (æ€§åˆ¥)
    const isGenderStep = (i === totalSteps - 1);
    // å¦‚æœæ˜¯æœ€å¾Œä¸€æ­¥ï¼Œå¼·åˆ¶é¡¯ç¤ºèƒ¸å‰æç¤ºï¼›å¦å‰‡é¡¯ç¤ºè§’è‰²å°ˆå±¬æç¤º
    renderPoseGuide(isGenderStep);

    // 1. æ¨™é¡Œèˆ‡ç•«é¢è¨­å®š
    setStepUI(i);
    await sleep(2000);
    
    // 2. ç·´ç¿’æ™‚é–“
    loading.classList.remove('show');
    centerStatus.textContent = "ç·´ç¿’æ™‚é–“";
    centerStatus.classList.add('active');
    await waitVideoLoops(3);
    
    // 3. å€’æ•¸
    await countdownCenter(); 
    
    // 4. æ‹æ”
    centerStatus.textContent = "æ‹æ”ä¸­";
    const clipBlob = await recordClip(2500);
    await saveClipToDB(clipBlob, i);
    
    // 5. æ®µè½çµæŸ
    centerStatus.classList.remove('active');
  }
  
  localStorage.setItem('booth_clip_count', totalSteps);

  msgTitle.textContent = 'æ‹æ”å®Œæˆ';
  msgSub.textContent = 'è™•ç†ä¸­...';
  loading.classList.add('show');
  
  await stopFullRecording();

  localStorage.setItem('photobooth_job', JSON.stringify({ done: true, time: Date.now() }));
  await sleep(1000);
  location.href = 'booth-export.html';
}

startBtn.onclick = async ()=>{
  try{ await shoot(); }
  catch(err){ console.error(err); alert('éŒ¯èª¤'); location.reload(); }
};

startCamera();

(function(){
  function setVH(){ document.documentElement.style.setProperty('--vh', window.innerHeight * 0.01 + 'px'); }
  window.addEventListener('resize', setVH); setVH();
})();

// ... (æ¥åœ¨åŸæœ¬ script çš„æœ€å¾Œé¢)

(function(){
  const cursor = document.getElementById('fake-cursor');
  let mouseX = -100, mouseY = -100; 
  let curX = -100, curY = -100;

  document.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });

  document.addEventListener('mousedown', () => cursor.classList.add('is-clicking'));
  document.addEventListener('mouseup', () => cursor.classList.remove('is-clicking'));

  function renderCursor() {
    curX += (mouseX - curX) * 0.2;
    curY += (mouseY - curY) * 0.2;
    cursor.style.transform = `translate3d(${curX}px, ${curY}px, 0)`;
    requestAnimationFrame(renderCursor);
  }
  renderCursor();
})();
</script>
</body>
</html>